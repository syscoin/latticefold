//! Special subset-sum decoder used in DPP query packing (Fact 5.20).
//!
//! We implement the decoder for the specific weight structure generated by Construction 5.21.

use num_bigint::BigInt;
use num_integer::Integer;
use num_traits::{One, Signed, Zero};
use thiserror::Error;

#[derive(Debug, Error)]
pub enum SubsetSumError {
    #[error("no bounded decomposition exists for packed value")]
    NoSolution,
    #[error("invalid parameters: k must be > 0")]
    InvalidK,
}

/// Decode `a = <ans, w>` over the integers with bounds `|ans_i| <= b_i-1`.
///
/// This corresponds to Fact 5.20 in the DPP paper; the decoder is efficient given
/// the promise that `w` satisfies a superincreasing-style condition:
///
/// `w_i > 2 * sum_{j<i} (b_j - 1) * w_j`.
///
/// Inputs/outputs are integer representatives (not field elements).
pub fn decode_bounded_subset_sum(a: &BigInt, w: &[BigInt], b: &[BigInt]) -> Result<Vec<BigInt>, SubsetSumError> {
    if w.is_empty() || b.is_empty() || w.len() != b.len() {
        return Err(SubsetSumError::InvalidK);
    }
    let k = w.len();

    // Precompute the max remainder representable by the prefix [0..i):
    // R[i] = sum_{j<i} (b_j - 1) * w_j  (always >= 0).
    let mut rem_bound_prefix: Vec<BigInt> = Vec::with_capacity(k + 1);
    rem_bound_prefix.push(BigInt::zero());
    for i in 0..k {
        let bound_i = &b[i] - BigInt::one();
        if bound_i.is_negative() {
            return Err(SubsetSumError::NoSolution);
        }
        let next = &rem_bound_prefix[i] + (&bound_i * &w[i]);
        rem_bound_prefix.push(next);
    }

    // Decode from largest weight to smallest.
    //
    // At step i, let R_i = sum_{j<i} (b_j - 1) * w_j (max representable magnitude by smaller weights).
    // We need to choose a_i in [-B_i, B_i] (where B_i=b_i-1) such that:
    //   rem - a_i * w_i âˆˆ [-R_i, R_i].
    //
    // For w_i > 0 this is equivalent to:
    //   (rem - R_i)/w_i <= a_i <= (rem + R_i)/w_i
    // and we intersect with [-B_i, B_i].
    //
    // Under the Fact 5.20 superincreasing promise, if a solution exists it is unique and this
    // interval will contain (at most) one integer.
    let mut ans = vec![BigInt::zero(); k];
    let mut rem = a.clone();

    for idx_rev in 0..k {
        let i = k - 1 - idx_rev;
        let wi = &w[i];
        if wi.is_zero() || wi.is_negative() {
            return Err(SubsetSumError::NoSolution);
        }
        let bound_i = &b[i] - BigInt::one();
        let max_rem = &rem_bound_prefix[i]; // representable by smaller weights
        if bound_i.is_negative() {
            return Err(SubsetSumError::NoSolution);
        }
        let neg_bound_i = -bound_i.clone();

        // Compute the admissible interval for a_i.
        let lo_num = &rem - max_rem;
        let hi_num = &rem + max_rem;
        let lo = ceil_div(&lo_num, wi);
        let hi = floor_div(&hi_num, wi);

        // Intersect with [-B_i, B_i].
        let lo2 = lo.max(neg_bound_i);
        let hi2 = hi.min(bound_i.clone());
        if lo2 > hi2 {
            return Err(SubsetSumError::NoSolution);
        }

        // Choose the (unique) feasible integer. Prefer lo2.
        let ai = lo2;
        let new_rem = &rem - (&ai * wi);
        if new_rem.abs() > *max_rem {
            return Err(SubsetSumError::NoSolution);
        }
        ans[i] = ai;
        rem = new_rem;
    }

    if !rem.is_zero() {
        return Err(SubsetSumError::NoSolution);
    }
    Ok(ans)
}

fn floor_div(a: &BigInt, b: &BigInt) -> BigInt {
    // b > 0 assumed.
    let (q, _r) = a.div_mod_floor(b);
    q
}

fn ceil_div(a: &BigInt, b: &BigInt) -> BigInt {
    // b > 0 assumed.
    let (q, r) = a.div_mod_floor(b);
    if r.is_zero() {
        q
    } else {
        q + BigInt::one()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use num_bigint::ToBigInt;

    #[test]
    fn test_decode_simple_unique() {
        // Example superincreasing weights with b=(3,3,3) => bounds=2.
        let w = vec![1.to_bigint().unwrap(), 10.to_bigint().unwrap(), 200.to_bigint().unwrap()];
        let b = vec![3.to_bigint().unwrap(), 3.to_bigint().unwrap(), 3.to_bigint().unwrap()];
        let ans = vec![2.to_bigint().unwrap(), (-1).to_bigint().unwrap(), 1.to_bigint().unwrap()];
        let a = &ans[0] * &w[0] + &ans[1] * &w[1] + &ans[2] * &w[2];
        let dec = decode_bounded_subset_sum(&a, &w, &b).unwrap();
        assert_eq!(dec, ans);
    }

    #[test]
    fn test_decode_no_solution() {
        let w = vec![1.to_bigint().unwrap(), 10.to_bigint().unwrap(), 200.to_bigint().unwrap()];
        let b = vec![3.to_bigint().unwrap(), 3.to_bigint().unwrap(), 3.to_bigint().unwrap()];
        // 999 can't be represented with bounds 2.
        assert!(decode_bounded_subset_sum(&999.to_bigint().unwrap(), &w, &b).is_err());
    }
}

